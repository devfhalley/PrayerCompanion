{% extends "layout.html" %}

{% block title %}Push to Talk - Prayer Alarm System{% endblock %}

{% block content %}
<div class="card">
    <div class="card-header">
        <h2>Push to Talk</h2>
    </div>
    
    <div class="push-to-talk" id="push-to-talk-container">
        <div id="status-message">Initializing WebSocket...</div>
        
        <!-- PTT Status Indicator -->
        <div class="ptt-connection-status">
            <span>Push-to-Talk Status: </span>
            <span class="ptt-status-indicator disconnected">Disconnected</span>
        </div>

        <!-- Replit Environment Notice (will be shown when in Replit) -->
        <div id="replit-notice" class="alert alert-info" style="display: none; margin: 15px 0;">
            <i class="fas fa-info-circle"></i>
            <strong>WebSockets are disabled in the Replit environment.</strong>
            <p>Push-to-Talk requires WebSockets and only works when deployed to a Raspberry Pi or other server.</p>
            <p>This is a Replit limitation due to proxy/firewall restrictions.</p>
            <p>The feature will work automatically when running on the production system.</p>
        </div>
        
        <div class="ptt-button" id="ptt-button">
            <i class="fas fa-microphone ptt-icon"></i>
        </div>
        
        <p class="mt-4">Press and hold the button to talk</p>
        
        <!-- Status messages for push-to-talk -->
        <div id="ptt-status" class="mt-2"></div>
        
        <!-- Someone is speaking indicator -->
        <div id="ptt-active-indicator" class="alert alert-warning mt-2" style="display: none;">
            Someone is speaking...
        </div>
        
        <div class="push-to-talk-info mt-4">
            <div class="info-item">
                <i class="fas fa-info-circle"></i>
                <span>Audio will be played through the Raspberry Pi speaker</span>
            </div>
            <div class="info-item">
                <i class="fas fa-volume-up"></i>
                <span>Push-to-talk has priority 5 in the audio system (Adhan > Pre-adhan > Tahrim > Alarm > Push-to-talk > Murattal)</span>
            </div>
            <div class="info-item">
                <i class="fas fa-shield-alt"></i>
                <span>This feature requires HTTPS for microphone access in most browsers</span>
            </div>
            <div class="info-item">
                <i class="fas fa-server"></i>
                <span>This feature requires a direct connection to the Raspberry Pi and is disabled in Replit</span>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const pttButton = document.getElementById('ptt-button');
    const statusMessage = document.getElementById('status-message');
    const pttStatusIndicator = document.querySelector('.ptt-status-indicator');
    let isRecording = false;
    let mediaRecorder = null;
    let audioChunks = [];
    
    // Request access to the microphone
    async function initAudio() {
        try {
            // First, check if the MediaDevices API is available
            if (!navigator.mediaDevices) {
                // Polyfill for older browsers
                navigator.mediaDevices = {};
            }
            
            // Check if getUserMedia is available
            if (!navigator.mediaDevices.getUserMedia) {
                const errorMsg = 'Browser does not support getUserMedia API, which is required for Push-to-Talk.';
                console.error(errorMsg);
                statusMessage.textContent = errorMsg;
                statusMessage.style.color = 'red';
                return false;
            }
            
            // Request audio with specific constraints for voice
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100,
                    channelCount: 1
                } 
            });
            
            // Use a different MIME type - wav works better for our backend
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus'
            });
            
            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = function() {
                if (audioChunks.length > 0 && window.pttWs && window.pttWs.isConnected()) {
                    // Combine chunks and convert to base64
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                    const reader = new FileReader();
                    
                    reader.onloadend = function() {
                        const base64data = reader.result.split(',')[1];
                        
                        // Add format information to help the server process it correctly
                        const message = {
                            type: 'ptt_audio',
                            data: base64data,
                            format: 'webm_opus'
                        };
                        
                        // Use the dedicated PTT WebSocket
                        window.pttWs.send(message);
                    };
                    
                    reader.readAsDataURL(audioBlob);
                    audioChunks = [];
                }
            };
            
            statusMessage.textContent = 'Microphone access granted';
            statusMessage.style.color = 'green';
            return true;
        } catch (error) {
            console.error('Error accessing microphone:', error);
            statusMessage.textContent = 'Microphone access denied or unavailable in this browser';
            statusMessage.style.color = 'red';
            return false;
        }
    }
    
    // Handle button press/release
    function setupPushToTalk() {
        pttButton.addEventListener('mousedown', startTalking);
        pttButton.addEventListener('touchstart', function(e) {
            e.preventDefault(); // Prevent touch scrolling
            startTalking();
        });
        
        pttButton.addEventListener('mouseup', stopTalking);
        pttButton.addEventListener('mouseleave', stopTalking);
        pttButton.addEventListener('touchend', stopTalking);
        pttButton.addEventListener('touchcancel', stopTalking);
    }
    
    function startTalking() {
        if (!window.pttWs || !window.pttWs.isConnected() || !mediaRecorder) {
            statusMessage.textContent = 'Cannot start talking - connection or microphone issue';
            return;
        }
        
        if (isRecording) return;
        
        isRecording = true;
        pttButton.classList.add('active');
        statusMessage.textContent = 'Talking...';
        
        // Send start message using the dedicated PTT WebSocket
        const message = {
            type: 'ptt_start'
        };
        window.pttWs.send(message);
        
        // Start recording
        audioChunks = [];
        mediaRecorder.start(100); // Collect data every 100ms
    }
    
    function stopTalking() {
        if (!isRecording) return;
        
        isRecording = false;
        pttButton.classList.remove('active');
        statusMessage.textContent = 'Connected - Ready to talk';
        
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
        
        // Send stop message using the dedicated PTT WebSocket
        if (window.pttWs && window.pttWs.isConnected()) {
            const message = {
                type: 'ptt_stop'
            };
            window.pttWs.send(message);
        }
    }
    
    // Update the UI when the WebSocket status changes
    function updateConnectionStatus() {
        // Check if we have dedicated PTT WebSocket available
        if (window.pttWs && window.pttWs.isConnected()) {
            statusMessage.textContent = 'Connected - Ready to talk';
            pttButton.classList.add('ready');
            pttButton.classList.remove('disabled');
            pttButton.style.backgroundColor = '';
            pttButton.style.cursor = '';
            
            if (pttStatusIndicator) {
                pttStatusIndicator.classList.remove('disconnected');
                pttStatusIndicator.classList.add('connected');
                pttStatusIndicator.textContent = 'Connected';
            }
        } else {
            statusMessage.textContent = 'Disconnected - Waiting for connection...';
            pttButton.classList.remove('ready');
            
            if (pttStatusIndicator) {
                pttStatusIndicator.classList.remove('connected');
                pttStatusIndicator.classList.add('disconnected');
                pttStatusIndicator.textContent = 'Disconnected';
            }
        }
    }
    
    // Initialize everything
    async function initialize() {
        // Check if we're in the Replit environment first
        if (isReplitEnvironment()) {
            // In Replit environment, display the notice
            const replitNotice = document.getElementById('replit-notice');
            if (replitNotice) {
                replitNotice.style.display = 'block';
            }
            
            statusMessage.innerHTML = '<strong style="color:#e74c3c;">WebSockets Disabled</strong> - Push-to-Talk only works when deployed to a real server';
            pttButton.classList.add('disabled');
            pttButton.style.backgroundColor = '#ccc';
            pttButton.style.cursor = 'not-allowed';
            
            if (pttStatusIndicator) {
                pttStatusIndicator.textContent = 'Disabled in Replit';
            }
            
            // Log the information to console
            console.log("Push-to-Talk is disabled in Replit environment due to WebSocket limitations");
            return;
        }
        
        // If not in Replit, proceed with normal initialization
        const hasAudio = await initAudio();
        if (hasAudio) {
            // The dual WebSockets should be set up by our main websocket_client.js script
            // We just need to check for the connection status and set up the UI
            
            // Set up a periodic check for WebSocket status
            setInterval(updateConnectionStatus, 1000);
            
            // Set up the push-to-talk button handlers
            setupPushToTalk();
            
            // Initial status update
            updateConnectionStatus();
        }
    }
    
    initialize();
    
    // Add some styling
    const style = document.createElement('style');
    style.textContent = `
        #ptt-button.ready { background-color: var(--primary-color); }
        #ptt-button.active { transform: scale(0.95); background-color: var(--error-color); }
        #status-message { margin-bottom: 20px; }
        .ptt-connection-status { margin-bottom: 15px; }
        .ptt-status-indicator.connected { color: green; font-weight: bold; }
        .ptt-status-indicator.disconnected { color: red; font-weight: bold; }
        #ptt-status { min-height: 20px; font-weight: bold; }
        #ptt-status.success { color: green; }
        #ptt-status.error { color: red; }
        #ptt-active-indicator { font-weight: bold; text-align: center; }
    `;
    document.head.appendChild(style);
});
</script>
{% endblock %}
